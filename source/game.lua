---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dreadnought.
--- DateTime: 03/06/2022 20:39
---
import "CoreLibs/graphics"
import "CoreLibs/object"
import "turning_block"
import "tool"
import "levels"
import "list"
import "blueprint"
import "sounds"

class("Game").extends()

function Game:init()
    self.turning_block = TurningBlock()
    self.tool = Tool()
    self.cut_done = 0
    self.chips = List()
    self.this_level = Blueprint(levels.l1)
    self.blueprint_visible = false
    self.hud_visual = playdate.graphics.image.new("image/hud.png")
    self.machine_visual = playdate.graphics.image.new("image/machine.png")
    self.chip_sounds = 0
    self.end_level_scene = false
    --self.drop_sound= playdate.sound.fileplayer.new(2)
    --self.drop_sound:load("sounds/drop.wav")

    --local v = self.drop_sound:play(1)
    --print(self.drop_sound:getVolume())
    --self.drop_sample  = playdate.sound.sampleplayer.new("sounds/drop.wav")



    self.howto_visual  = playdate.graphics.image.new("image/howto.png")
    self.wheels_are_turning = false
    self.knife_is_not_cutting = true
end

function Game:lets_roll()
    start_sample:play()
    running_sample:play(0)
    self.wheels_are_turning = true
    self.knife_is_not_cutting = false
    self.tool:reset_tool(false)
    self.end_level_scene = false
end

function Game:hammer_time()
    running_sample:stop()
    end_sample:play()
    self.wheels_are_turning = false
    self.knife_is_not_cutting = true
    self.end_level_scene = true
end

function Game:restart()
    self.turning_block:restart()
    self.tool:reset_tool()
end


function Game:horizontal_button()
    local buttonX = 0
    if playdate.buttonIsPressed(playdate.kButtonLeft )  then
        buttonX = buttonX - 1
    end
    if playdate.buttonIsPressed(playdate.kButtonRight ) then
        buttonX = buttonX + 1
    end
    return buttonX
end

function Game:vertical_button()
    local buttonY = 0
    if playdate.buttonIsPressed(playdate.kButtonUp)  then
        buttonY = buttonY + 1
    end
    if playdate.buttonIsPressed(playdate.kButtonDown) then
        buttonY = buttonY - 1
    end
    return buttonY
end


function Game:update()
    if not self.blueprint_visible then
        self:move_tool_x(Game:horizontal_button()*horizontal_button_sensitivity)
        self:move_tool_y(Game:vertical_button()*vertical_button_sensitivity)
    end

    if not self.knife_is_not_cutting then
        for i = 1,self.tool.width do
            if self.turning_block.block_distance[self.tool.x + i] then
                if self.turning_block.block_distance[self.tool.x + i]~=0 then
                    local this_cut = 240 - log_centre - self.tool.y - self.tool:active_profile()[i]
                    if self.turning_block.block_distance[self.tool.x + i]>this_cut then
                        self.cut_done  = 0
                        self.turning_block.block_distance[self.tool.x + i] = math.max(math.min(self.turning_block.block_distance[self.tool.x + i],this_cut),0)

                        for j = 1,2 do
                            local chip_x = self.tool.x + i+tool_offset_x + math.random(1,7) - 4
                            local chip_y = 240 - self.tool.y - self.tool:active_profile()[i] + math.random(1,10) - 3
                            self.chips:append(Point(chip_x, chip_y))
                        end

                        if self.chip_sounds==0 then
                            filing_sample:play(0)
                        end
                        self.chip_sounds = 10


                    end
                end
            else
                break
            end
        end

    end

end

function Game:move_tool_y(d)
    if not  self.blueprint_visible then
        if self.cut_done~=0 and math.abs(d)>0 then
            self.cut_done = self.cut_done-1
        else
            self.tool:move_by_y(d*crank_vertical_sensitivity)
        end
    end
end

function Game:move_tool_x(d)
    self.tool:move_by_x(d)
end


function Game:calculate_score()
    s = 0
    for i = 1,320 do
        s = s + math.max(0,
                    math.abs(
                    self.this_level.values[i] - self.turning_block.block_distance[i]
            )-3
        )

    end
    return s
end


function Game:draw()
    self.chip_sounds = math.max( self.chip_sounds -1,0)


    if self.chip_sounds==0 then
        filing_sample:stop()
    end

    if self.blueprint_visible then
        self.turning_block:draw(false)
        --self.this_level:draw()
        self.this_level:draw_low_half()
        --self.turning_block:drawOutline(playdate.graphics.kColorXOR)

        self.tool:draw()
    else
        self.turning_block:draw(self.wheels_are_turning)
        self.turning_block:drawOutline(playdate.graphics.kColorBlack)
        --dark_bg:draw(0,0)
        --test_pause:draw(0,0)
        self.tool:draw()
        playdate.graphics.setColor(playdate.graphics.kColorWhite)
        self.chips:iterate(
                function( p  ) playdate.graphics.drawPixel(p.x,p.y);playdate.graphics.drawPixel(p.x,p.y+1) end
        )
        self.chips:clear()
    end




    self:draw_score()


    self.machine_visual:draw(0,0)
    --playdate.graphics.drawText(self.this_level.inner_diff, 200,220)
    --playdate.graphics.drawText(self.this_level.outer_diff, 100,220)
end


function Game:draw_score()
    self.hud_visual:draw(0,0)

    local score_perc =  self:calculate_score()/self.this_level.outer_diff*103 - 3
    local score_capped = math.max(math.min(100,score_perc),0)
    local score_string = tostring( math.min(  math.floor(100-score_capped) ,100)) --.. "% complete"
    playdate.graphics.drawTextAligned(score_string, 367,70,kTextAlignment.center)

    playdate.graphics.drawTextAligned(tostring(properties.active_level), 367,26,kTextAlignment.center)

    --playdate.graphics.drawTextAligned(score_perc, 367,170,kTextAlignment.center)
end


function Game:save_state()
    playdate.datastore.write(self.turning_block.block_distance , "active_level")
end

function Game:load_state()
    local m = playdate.datastore.read( "active_level")
    if m~=nil then
        self.turning_block.block_distance = m
    end

end