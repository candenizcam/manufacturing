---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by dreadnought.
--- DateTime: 03/06/2022 20:39
---
import "CoreLibs/graphics"
import "CoreLibs/object"
import "turning_block"
import "tool"
import "levels"
import "list"
import "blueprint"

class("Game").extends()

function Game:init()
    self.turning_block = TurningBlock()
    self.tool = Tool()
    self.cut_done = 0
    self.chips = List()
    self.this_level = Blueprint(levels.l1)
    self.blueprint_visible = false


    self.howto_visual  = playdate.graphics.image.new("image/howto.png")
end

function Game:restart()
    self.turning_block:restart()
    self.tool:reset_tool()
end


function Game:horizontal_button()
    local buttonX = 0
    if playdate.buttonIsPressed(playdate.kButtonLeft )  then
        buttonX = buttonX - 1
    end
    if playdate.buttonIsPressed(playdate.kButtonRight ) then
        buttonX = buttonX + 1
    end
    return buttonX
end

function Game:vertical_button()
    local buttonY = 0
    if playdate.buttonIsPressed(playdate.kButtonUp)  then
        buttonY = buttonY + 1
    end
    if playdate.buttonIsPressed(playdate.kButtonDown) then
        buttonY = buttonY - 1
    end
    return buttonY
end


function Game:update()
    if not self.blueprint_visible then
        self:move_tool_x(Game:horizontal_button()*horizontal_button_sensitivity)
        self:move_tool_y(Game:vertical_button()*vertical_button_sensitivity)
    end

    for i = 0,self.tool.width do
        if self.turning_block.block_distance[self.tool.x + i] then
            if self.turning_block.block_distance[self.tool.x + i]~=0 then
                local this_cut = 240 - log_centre - self.tool.y - self.tool.active_profile[i]
                if self.turning_block.block_distance[self.tool.x + i]>this_cut then
                    self.cut_done  = 0
                    self.turning_block.block_distance[self.tool.x + i] = math.max(math.min(self.turning_block.block_distance[self.tool.x + i],this_cut),0)

                    for j = 1,2 do
                        local chip_x = self.tool.x + i+tool_offset_x + math.random(1,7) - 4
                        local chip_y = 240 - self.tool.y - self.tool.active_profile[i] + math.random(1,10) - 3
                        self.chips:append(Point(chip_x, chip_y))
                    end


                end
            end
        else
            break
        end
    end
end

function Game:move_tool_y(d)
    if not  self.blueprint_visible then
        if self.cut_done~=0 and math.abs(d)>0 then
            self.cut_done = self.cut_done-1
        else
            self.tool:move_by_y(d*crank_vertical_sensitivity)
        end
    end
end

function Game:move_tool_x(d)
    self.tool:move_by_x(d)
end


function Game:calculate_score()
    s = 0
    for i = 1,320 do
        s = s + math.abs(
                self.this_level.values[i] - self.turning_block.block_distance[i]
        )

    end
    return s
end


function Game:draw()

    if self.blueprint_visible then
        self.turning_block:draw(false)
        --self.this_level:draw()
        self.this_level:draw_low_half()
        --self.turning_block:drawOutline(playdate.graphics.kColorXOR)

        self.tool:draw()
    else
        self.turning_block:draw(true)
        self.turning_block:drawOutline(playdate.graphics.kColorBlack)
        self.tool:draw()
        playdate.graphics.setColor(playdate.graphics.kColorXOR)
        self.chips:iterate(
                function( p  ) playdate.graphics.drawPixel(p.x,p.y);playdate.graphics.drawPixel(p.x,p.y+1) end
        )
        self.chips:clear()
    end

    local score_perc =  self:calculate_score()/self.this_level.outer_diff*100
    playdate.graphics.drawText(tostring( math.min(  math.floor(110-score_perc) ,100)).. "% complete", 200,220)
    --playdate.graphics.drawText(self.this_level.inner_diff, 200,220)
    --playdate.graphics.drawText(self.this_level.outer_diff, 100,220)
end


function Game:save_state()
    playdate.datastore.write(self.turning_block.block_distance , "active_level")
end

function Game:load_state()
    self.turning_block.block_distance = playdate.datastore.read( "active_level")
end